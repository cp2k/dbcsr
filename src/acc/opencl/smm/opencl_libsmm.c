/*------------------------------------------------------------------------------------------------*
 * Copyright (C) by the DBCSR developers group - All rights reserved                              *
 * This file is part of the DBCSR library.                                                        *
 *                                                                                                *
 * For information on the license, see the LICENSE file.                                          *
 * For further information please visit https://dbcsr.cp2k.org                                    *
 * SPDX-License-Identifier: GPL-2.0+                                                              *
 *------------------------------------------------------------------------------------------------*/
#if defined(__OPENCL)
#include "opencl_libsmm.h"
/* Header opencl_kernels.h is generated by the build system using acc_opencl.sh */
#include "opencl_kernels.h"
#include <libxsmm_sync.h>
#include <assert.h>
#if defined(_OPENMP)
# include <omp.h>
#endif

#if LIBXSMM_VERSION3(1, 16, 1) <= LIBXSMM_VERSION3(LIBXSMM_VERSION_MAJOR, \
    LIBXSMM_VERSION_MINOR, LIBXSMM_VERSION_UPDATE) && 808 <= LIBXSMM_VERSION_PATCH
# define OPENCL_LIBSMM_REGISTER(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT) \
    libxsmm_xregister(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT, NULL/*key_hash*/)
# define OPENCL_LIBSMM_DISPATCH(KEY, KEY_SIZE) \
    libxsmm_xdispatch(KEY, KEY_SIZE, NULL/*key_hash*/)
#else
# define OPENCL_LIBSMM_REGISTER(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT) \
    libxsmm_xregister(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT)
# define OPENCL_LIBSMM_DISPATCH(KEY, KEY_SIZE) \
    libxsmm_xdispatch(KEY, KEY_SIZE)
#endif

#if !defined(OPENCL_LIBSMM_DEBUG_TRANS) && defined(OPENCL_LIBSMM_DEBUG)
# define OPENCL_LIBSMM_DEBUG_TRANS
#endif
#if !defined(OPENCL_LIBSMM_DEBUG_SMM) && defined(OPENCL_LIBSMM_DEBUG)
# define OPENCL_LIBSMM_DEBUG_SMM
#endif
#if !defined(OPENCL_LIBSMM_NLOCKS_TRANS)
# define OPENCL_LIBSMM_NLOCKS_TRANS 16
#endif
#if !defined(OPENCL_LIBSMM_NLOCKS_SMM)
# define OPENCL_LIBSMM_NLOCKS_SMM 16
#endif


#if defined(__cplusplus)
extern "C" {
#endif

int opencl_libsmm_initialized;
volatile int opencl_libsmm_lock_trans[OPENCL_LIBSMM_NLOCKS_TRANS];
volatile int opencl_libsmm_lock_smm[OPENCL_LIBSMM_NLOCKS_SMM];


int opencl_libsmm_use_cmem(cl_device_id device)
{
#if defined(OPENCL_LIBSMM_CMEM)
  int result = EXIT_SUCCESS;
  cl_ulong size_maxalloc = 1, size_maxcmem = 0;
  ACC_OPENCL_CHECK(clGetDeviceInfo(device, CL_DEVICE_MAX_MEM_ALLOC_SIZE,
    sizeof(cl_ulong), &size_maxalloc, NULL), "retrieve maximum size of memory allocation", result);
  ACC_OPENCL_CHECK(clGetDeviceInfo(device, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE,
    sizeof(cl_ulong), &size_maxcmem, NULL), "retrieve maximum size of constant buffer", result);
  return (EXIT_SUCCESS == result ? (size_maxalloc <= size_maxcmem ? EXIT_SUCCESS : EXIT_FAILURE) : result);
#else
  ACC_OPENCL_UNUSED(device);
  return EXIT_FAILURE;
#endif
}


#if defined(OPENCL_LIBSMM_DEBUG) && defined(_DEBUG)
void opencl_libsmm_print_matrix(FILE* ostream, const char* label, libsmm_acc_data_t type, const void* mat, int m, int n)
{
  int i, j;
  const char *const s = (NULL != label ? label : "");
  const int len = (int)strlen(s);
  for (i = 0; i < m; ++i) {
    if (0 < i) fprintf(ostream, "%*s", len, " "); else fprintf(ostream, "%s", s);
    for (j = 0; j < n; ++j) {
      switch (type) {
        case dbcsr_type_real_8: fprintf(ostream, "%.2f ", ((double*)mat)[i*n+j]); break;
        case dbcsr_type_real_4: fprintf(ostream, "%.2f ", ((float*) mat)[i*n+j]); break;
        default: fprintf(ostream, "? ");
      }
    }
    fprintf(ostream, "\n");
  }
}
#endif


int opencl_libsmm_read_params(char* parambuf,
  opencl_libsmm_smmkey_t* key, opencl_libsmm_smm_t* value)
{
  const char* s = strtok(parambuf, OPENCL_LIBSMM_PARAMS_DELIMS);
  int consumed = 0, t = 0, i;
  assert(NULL != key && NULL != value);
  for (; NULL != s; s = strtok(NULL, OPENCL_LIBSMM_PARAMS_DELIMS), ++t) {
    switch (t) {
      case 0: if (1 == sscanf(s, "%i", &i)) {
        key->type = (libsmm_acc_data_t)i; ++consumed;
      } break;
      case 1: if (1 == sscanf(s, "%i", &i)) {
        key->m = i; ++consumed;
      } break;
      case 2: if (1 == sscanf(s, "%i", &i)) {
        key->n = i; ++consumed;
      } break;
      case 3: if (1 == sscanf(s, "%i", &i)) {
        key->k = i; ++consumed;
      } break;
      case 5: if (1 == sscanf(s, "%i", &i)) {
        value->bs = i; ++consumed;
      } break;
      case 6: if (1 == sscanf(s, "%i", &i)) {
        value->bm = i; ++consumed;
      } break;
      case 7: if (1 == sscanf(s, "%i", &i)) {
        value->bn = i; ++consumed;
      } break;
    }
  }
  return (7 == consumed ? EXIT_SUCCESS : EXIT_FAILURE);
}


int libsmm_acc_init(void)
{
#if defined(_OPENMP)
  /* initialization/finalization is not meant to be thread-safe */
  int result = ((0 == omp_in_parallel()
# if /*WORKAROUND*/defined(__DBCSR_ACC)
    || 0/*master*/ == omp_get_thread_num()
# endif
    ) ? EXIT_SUCCESS : EXIT_FAILURE);
#else
  int result = EXIT_SUCCESS;
#endif
  /* multiple calls to libsmm_acc_init are not considered as an error */
  if (1 == LIBXSMM_ATOMIC_ADD_FETCH(&opencl_libsmm_initialized, 1, LIBXSMM_ATOMIC_RELAXED)) {
#if !defined(__DBCSR_ACC)
    /* DBCSR shall call acc_init as well as libsmm_acc_init (since both interfaces are used).
     * Also, libsmm_acc_init may privately call acc_init (as it depends on the ACC interface).
     * The implementation of acc_init should hence be safe against "over initialization".
     * However, DBCSR only calls acc_init (and expects an implicit libsmm_acc_init).
     */
    if (EXIT_SUCCESS == result) {
      result = c_dbcsr_acc_init();
    }
#endif
    if (EXIT_SUCCESS == result) {
      char buffer[ACC_OPENCL_BUFFERSIZE];
      const char *const env_params = getenv("OPENCL_LIBSMM_SMM_PARAMS");
      opencl_libsmm_smm_t config;
      opencl_libsmm_smmkey_t key;
      /* zeroing config once (tuned parameters are setup below) */
      LIBXSMM_MEMZERO127(&config);
      /* potentially heterogeneous key-data */
      LIBXSMM_MEMZERO127(&key);
      if (NULL == env_params || '0' != *env_params) {
        if (NULL != env_params && '\0' != *env_params) {
          FILE *const file = fopen(env_params, "r");
          /* consume first line and skip CSV header line */
          if (NULL == file || NULL == fgets(buffer, ACC_OPENCL_BUFFERSIZE, file)) {
            result = EXIT_FAILURE;
          }
          while (EXIT_SUCCESS == result &&
            NULL != fgets(buffer, ACC_OPENCL_BUFFERSIZE, file))
          {
            result = opencl_libsmm_read_params(buffer, &key, &config);
            if (EXIT_SUCCESS == result &&
              NULL == OPENCL_LIBSMM_REGISTER(&key, sizeof(key), sizeof(config), &config))
            {
              result = EXIT_FAILURE;
            }
          }
        }
#if defined(OPENCL_LIBSMM_PARAMS_SMM)
        else {
          const char* line = OPENCL_LIBSMM_PARAMS_SMM, *next;
          do {
            next = strchr(line, '\n');
            if (NULL != next && next < (line + ACC_OPENCL_BUFFERSIZE)) {
              const int len = next - line;
              memcpy(buffer, line, len); buffer[len] = '\0';
              result = opencl_libsmm_read_params(buffer, &key, &config);
              if (EXIT_SUCCESS == result &&
                NULL == OPENCL_LIBSMM_REGISTER(&key, sizeof(key), sizeof(config), &config))
              {
                result = EXIT_FAILURE; break;
              }
              line = ++next;
            }
          } while (NULL != next);
        }
#endif
      }
    }
  }
  ACC_OPENCL_RETURN(result);
}


int libsmm_acc_finalize(void)
{
  /* Routine libsmm_acc_init is called in master thread inside of parallel region
   * However, libsmm_acc_finalize is indirectly called (acc_finalize) inside of a
   * parallel region (not just the master thread).
   */
#if defined(_OPENMP)
  /* initialization/finalization is not meant to be thread-safe */
  int result = ((0 == omp_in_parallel()
# if /*WORKAROUND*/defined(__DBCSR_ACC)
    || 0/*master*/ == omp_get_thread_num()
# endif
    ) ? EXIT_SUCCESS : EXIT_FAILURE);
#else
  int result = EXIT_SUCCESS;
#endif
#if 0
  /* multiple calls to libsmm_acc_finalize are not considered as an error */
  if (0 == LIBXSMM_ATOMIC_SUB_FETCH(&opencl_libsmm_initialized, 1, LIBXSMM_ATOMIC_RELAXED)) {
  }
#endif
  /* acc_finalize is not called since it can be used independently */
  return result;
}


acc_bool_t libsmm_acc_is_thread_safe(void)
{
  /* match DBCSR's threading level */
#if defined(_OPENMP)
  return 1;
#else
  return 0;
#endif
}


int libsmm_acc_transpose(const int* dev_trs_stack, int offset, int stack_size,
  void* dev_data, libsmm_acc_data_t datatype, int m, int n, int max_kernel_dim, void* stream)
{
  const int mn = m * n;
  int result = EXIT_SUCCESS;
  assert((NULL != dev_trs_stack && NULL != dev_data && 0 <= offset && 0 <= stack_size) || 0 == stack_size);
  if ((
#if defined(OPENCL_LIBSMM_F64)
      dbcsr_type_real_8 == datatype
#else
      0
#endif
      ||
#if defined(OPENCL_LIBSMM_F32)
      dbcsr_type_real_4 == datatype
#else
      0
#endif
    ) &&
    0 < stack_size && 1 < mn && m <= max_kernel_dim && n <= max_kernel_dim)
  {
    const libxsmm_timer_tickint start = libxsmm_timer_tick();
    opencl_libsmm_trans_t* config;
    opencl_libsmm_transkey_t key;
    LIBXSMM_MEMZERO127(&key); /* potentially heterogeneous key-data */
    key.type = datatype; key.m = m; key.n = n; /* initialize key */
    config = (opencl_libsmm_trans_t*)OPENCL_LIBSMM_DISPATCH(&key, sizeof(key));
    if (NULL == config) {
      char build_options[ACC_OPENCL_BUFFERSIZE], fname[32];
      int nchar = ACC_OPENCL_SNPRINTF(fname, sizeof(fname), "xtrans%ix%i", m, n);
      if (0 < nchar && (int)sizeof(fname) > nchar) {
        cl_device_id active_device;
        result = c_dbcsr_acc_opencl_device(stream, &active_device);
        if (EXIT_SUCCESS == result) {
          const char *const env_options = getenv("OPENCL_LIBSMM_TRANS_BUILDOPTS");
          const char *const env_inplace = getenv("OPENCL_LIBSMM_TRANS_INPLACE");
          const char *const env_blockm = getenv("OPENCL_LIBSMM_TRANS_BLOCK_M");
          const int inplace = ((m == n) && ((NULL == env_inplace || '\0' == *env_inplace)
#if defined(OPENCL_LIBSMM_TRANS_INPLACE)
            ? 1 : ('0' != *env_inplace)));
#else
            ? 0 : ('0' != *env_inplace)));
#endif
          const int blockm = ((NULL == env_blockm || '\0' == *env_blockm)
            ? m/*TODO*/ : atoi(env_blockm));
          const int bm = LIBXSMM_CLMP(blockm, 1, m);
          const char* typename = "";
          int wgsize;
          switch (datatype) {
            case dbcsr_type_real_8: {
              typename = "char8"; /* double */
              fname[0] = 'd';
            } break;
            case dbcsr_type_real_4: {
              typename = "float";
              fname[0] = 's';
            } break;
            default: ;
          }
          wgsize = ((m == bm || 0 == (m % bm)) ? bm : m);
          nchar = ACC_OPENCL_SNPRINTF(build_options, sizeof(build_options), "%s"
            " -DGLOBAL=%s -DINPLACE=%i -DFN=%s -DSM=%i -DSN=%i -DSWG=%i -DT=%s",
            (NULL == env_options || '\0' == *env_options) ? "" : env_options,
            EXIT_SUCCESS != opencl_libsmm_use_cmem(active_device) ? "global" : "constant",
            inplace, fname, m, n, wgsize, typename);
          if ('\0' != *typename && 0 < nchar && (int)sizeof(build_options) > nchar) {
            opencl_libsmm_trans_t new_config;
#if defined(OPENCL_LIBSMM_SOURCE_TRANSPOSE)
            result = c_dbcsr_acc_opencl_kernel(OPENCL_LIBSMM_SOURCE_TRANSPOSE,
              build_options, fname, &new_config.kernel);
#else
            ACC_OPENCL_UNUSED(inplace);
            result = EXIT_FAILURE;
#endif
            if (EXIT_SUCCESS == result) {
              int max_wgsize;
              result = c_dbcsr_acc_opencl_wgsize(active_device, new_config.kernel,
                &max_wgsize, NULL/*preferred_multiple*/);
              if (EXIT_SUCCESS == result) {
                assert(0 < max_wgsize);
                if (wgsize <= max_wgsize) {
                  new_config.wgsize = (size_t)wgsize;
                  config = (opencl_libsmm_trans_t*)OPENCL_LIBSMM_REGISTER(&key, sizeof(key),
                    sizeof(new_config), &new_config);
                  if (1 < c_dbcsr_acc_opencl_options.verbosity || 0 > c_dbcsr_acc_opencl_options.verbosity) {
                    const double duration = libxsmm_timer_duration(start, libxsmm_timer_tick());
                    fprintf(stderr, "INFO ACC/OpenCL: %ix%i transpose-kernel generated in %.1f ms\n",
                      m, n, 1000.0 * duration);
                  }
                }
                else result = EXIT_FAILURE;
              }
            }
          }
          else {
            result = EXIT_FAILURE;
          }
        }
      }
      else {
        result = EXIT_FAILURE;
      }
    }
    assert((NULL != config && NULL != config->kernel && 0 < config->wgsize) || EXIT_SUCCESS != result);
    if (EXIT_SUCCESS == result) {
      const size_t work_size = config->wgsize * stack_size;
#if defined(OPENCL_LIBSMM_DEBUG_TRANS)
      const int offset_stack_size = offset + stack_size;
      int *const stack = (int*)libxsmm_aligned_scratch(sizeof(int) * offset_stack_size, 0/*auto-align*/);
      char *imat = NULL, *omat = NULL, *gold = NULL;
      const int typesize = (dbcsr_type_real_8 == datatype ? 8
        : (dbcsr_type_real_4 == datatype ? 4 : 0/*unknown*/));
      size_t data_size;
      if (NULL != stack && CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_data),
        CL_MEM_SIZE, sizeof(size_t), &data_size, NULL))
      {
        imat = (char*)libxsmm_aligned_scratch(data_size, 0/*auto-align*/);
        omat = (char*)libxsmm_aligned_scratch(data_size, 0/*auto-align*/);
        gold = (char*)libxsmm_aligned_scratch(mn * typesize, 0/*auto-align*/);
        if (NULL != imat && NULL != omat && NULL != gold) {
          ACC_OPENCL_CHECK(c_dbcsr_acc_memcpy_d2h(dev_trs_stack, stack, sizeof(int) * offset_stack_size, stream),
            "transfer debug stack", result);
          ACC_OPENCL_CHECK(c_dbcsr_acc_memcpy_d2h(dev_data, imat, data_size, stream),
            "transfer debug input", result);
        }
        else result = EXIT_FAILURE;
      }
      else result = EXIT_FAILURE;
#endif
      assert(!(OPENCL_LIBSMM_NLOCKS_TRANS & (OPENCL_LIBSMM_NLOCKS_TRANS - 1))); /* POT */
      { /* OpenCL is thread-safe except for clSetKernelArg and launching such shared kernel */
        const unsigned int hash = libxsmm_hash(&config->kernel, sizeof(cl_kernel), 25071975/*seed*/);
        volatile int *const lock = opencl_libsmm_lock_trans + LIBXSMM_MOD2(hash, OPENCL_LIBSMM_NLOCKS_TRANS);
        LIBXSMM_ATOMIC_ACQUIRE(lock, LIBXSMM_SYNC_NPAUSE, LIBXSMM_ATOMIC_RELAXED);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 0, sizeof(cl_mem), ACC_OPENCL_MEM(dev_trs_stack)),
          "set batch-list argument of transpose kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 1, sizeof(int), &offset),
          "set offset argument of transpose kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 2, sizeof(cl_mem), ACC_OPENCL_MEM(dev_data)),
          "set matrix-data argument of transpose kernel", result);
        ACC_OPENCL_CHECK(clEnqueueNDRangeKernel(*ACC_OPENCL_STREAM(stream),
          config->kernel, 1/*work_dim*/, NULL, &work_size, &config->wgsize, 0, NULL, NULL),
          "launch transpose kernel", result);
        LIBXSMM_ATOMIC_RELEASE(lock, LIBXSMM_ATOMIC_RELAXED);
      }
#if defined(OPENCL_LIBSMM_DEBUG_TRANS)
      ACC_OPENCL_CHECK(c_dbcsr_acc_memcpy_d2h(dev_data, omat, data_size, stream),
        "transfer debug test", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_TRANS) || defined(OPENCL_LIBSMM_SYNC)
      ACC_OPENCL_CHECK(c_dbcsr_acc_stream_sync(stream), "sync stream", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_TRANS)
      if (EXIT_SUCCESS == result) {
        int i, j;
        fprintf(stderr, "libsmm_acc_transpose("
          "offset=%i, size=%i, type=%s, m=%i, n=%i, max=%i, stream=%p)", offset, stack_size,
          dbcsr_type_real_8 == datatype ? "f64" : (dbcsr_type_real_4 == datatype ? "f32" : "unknown"),
          m, n, max_kernel_dim, stream);
        for (i = offset; i < offset_stack_size; ++i) {
          const size_t index = stack[i];
          const char *const orig = imat + index * typesize;
          const char *const test = omat + index * typesize;
          assert((index * typesize) < data_size);
          memcpy(gold, orig, mn * typesize);
          libxsmm_itrans(gold, typesize, m, n, m, n);
          if (0 != memcmp(gold, test, mn * typesize)) {
            fprintf(stderr, " => ERROR\n");
# if defined(_DEBUG)
            opencl_libsmm_print_matrix(stderr, "orig = ", datatype, orig, m, n);
            opencl_libsmm_print_matrix(stderr, "gold = ", datatype, gold, n, m);
            opencl_libsmm_print_matrix(stderr, "test = ", datatype, test, n, m);
            fprintf(stderr, "\n");
# endif
            result = EXIT_FAILURE; break;
          }
          for (j = offset; j < i; ++j) {
            const size_t duplicate = stack[j];
            if (index == duplicate) {
              fprintf(stderr, " => ERROR\n");
              result = EXIT_FAILURE;
              i = offset_stack_size;
              break;
            }
          }
        }
        if (EXIT_SUCCESS == result) fprintf(stderr, " => OK\n");
      }
      libxsmm_free(stack);
      libxsmm_free(imat);
      libxsmm_free(omat);
      libxsmm_free(gold);
#endif
    }
  }
  ACC_OPENCL_RETURN(result);
}


int libsmm_acc_process(const int* host_param_stack, const int* dev_param_stack, int stack_size,
  int nparams, libsmm_acc_data_t datatype, const void* dev_a_data, const void* dev_b_data, void* dev_c_data,
  int m_max, int n_max, int k_max, int max_kernel_dim, acc_bool_t def_mnk, void* stream, void* c_stream)
{
  int result = EXIT_SUCCESS;
  ACC_OPENCL_UNUSED(c_stream); /* TODO */
  assert(0 == stack_size || (NULL != host_param_stack && NULL != dev_param_stack
    && NULL != dev_a_data && NULL != dev_b_data && NULL != dev_c_data));
  assert(0 < nparams && 0 < max_kernel_dim && NULL != stream);
  assert(0 <= stack_size && 0 <= m_max && 0 <= n_max && 0 <= k_max);
  if ((
#if defined(OPENCL_LIBSMM_F64)
      dbcsr_type_real_8 == datatype
#else
      0
#endif
      ||
#if defined(OPENCL_LIBSMM_F32)
      dbcsr_type_real_4 == datatype
#else
      0
#endif
    ) &&
    0 < stack_size && def_mnk/*homogeneous*/ &&
    0 < m_max && m_max <= max_kernel_dim &&
    0 < n_max && n_max <= max_kernel_dim &&
    0 < k_max && k_max <= max_kernel_dim)
  {
    const libxsmm_timer_tickint start = libxsmm_timer_tick();
    opencl_libsmm_smm_t* config;
    opencl_libsmm_smmkey_t key;
    LIBXSMM_MEMZERO127(&key); /* potentially heterogeneous key-data */
    key.type = datatype; key.m = m_max; key.n = n_max; key.k = k_max; /* initialize key */
    config = (opencl_libsmm_smm_t*)OPENCL_LIBSMM_DISPATCH(&key, sizeof(key));
    if (NULL == config || NULL == config->kernel) {
      char build_options[ACC_OPENCL_BUFFERSIZE], fname[48];
      int nchar = ACC_OPENCL_SNPRINTF(fname, sizeof(fname), "xmm%ix%ix%i", m_max, n_max, k_max);
      const char* extensions = NULL;
      if (0 < nchar && (int)sizeof(fname) > nchar) {
        cl_device_id active_device;
        result = c_dbcsr_acc_opencl_device(stream, &active_device);
        if (EXIT_SUCCESS == result) {
          const char *atomic_cmpxchg = NULL, *atomic_xchg = NULL;
          const char *atomic_type = NULL, *typename = NULL;
          assert(NULL != active_device);
          switch (datatype) {
            case dbcsr_type_real_8: {
              extensions = "cl_khr_fp64 cl_khr_int64_base_atomics";
              if (EXIT_SUCCESS == c_dbcsr_acc_opencl_device_ext(active_device, &extensions, 1)) {
                atomic_cmpxchg = "atom_cmpxchg";
                atomic_xchg = "atom_xchg";
                atomic_type = "long";
                typename = "double";
                fname[0] = 'd';
              }
            } break;
            case dbcsr_type_real_4: {
              extensions = "cl_khr_global_int32_base_atomics";
              if (EXIT_SUCCESS == c_dbcsr_acc_opencl_device_ext(active_device, &extensions, 1)) {
                atomic_cmpxchg = "atomic_cmpxchg";
                atomic_xchg = "atomic_xchg";
                atomic_type = "int";
                typename = "float";
                fname[0] = 's';
              }
            } break;
            default: ;
          }
          if (NULL != typename) {
            const int nonvcl = (EXIT_SUCCESS != c_dbcsr_acc_opencl_device_vendor(active_device, "nvidia"));
            int max_wgsize, wgsize, bs, bm, bn, nbm, nbn;
            result = c_dbcsr_acc_opencl_wgsize(active_device, NULL/*device-specific*/,
              &max_wgsize, NULL/*preferred_multiple*/);
            if (EXIT_SUCCESS == result) {
              const char *const env_batchsize = getenv("OPENCL_LIBSMM_SMM_BATCHSIZE");
              const char *const env_blockm = getenv("OPENCL_LIBSMM_SMM_BLOCK_M");
              const char *const env_blockn = getenv("OPENCL_LIBSMM_SMM_BLOCK_N");
              /* TODO: load parameters from file (auto-tuned) */
              const int batchsize = ((NULL == env_batchsize || '\0' == *env_batchsize)
                ? (NULL == config ? 32/*default*/ : config->bs) : atoi(env_batchsize));
              const int blockm = ((NULL == env_blockm || '\0' == *env_blockm)
                ? (NULL == config ? m_max/*default*/ : config->bm) : atoi(env_blockm));
              const int blockn = ((NULL == env_blockn || '\0' == *env_blockn)
                ? (NULL == config ? 1/*default*/ : config->bn) : atoi(env_blockn));
              bm = LIBXSMM_CLMP(blockm, 1, m_max);
              bn = LIBXSMM_CLMP(blockn, 1, n_max);
              bs = LIBXSMM_MAX(batchsize, 1);
              nbm = (m_max + bm - 1) / bm;
              nbn = (n_max + bn - 1) / bn;
              wgsize = nbm * nbn;
              assert(1 <= bs && 0 < wgsize && 0 < max_wgsize);
              /* limit WG-size to device's maximum WG-size */
              while (max_wgsize < wgsize && (bm < m_max || bn < n_max)) {
                if (bn < n_max) {
                  ++bn; nbn = (n_max + bn - 1) / bn;
                }
                else if (bm < m_max) {
                  ++bm; nbm = (m_max + bm - 1) / bm;
                }
                wgsize = nbm * nbn;
              }
              if (wgsize <= max_wgsize) { /* SMMs can be potentially handled by device */
                const char *const env_options = getenv("OPENCL_LIBSMM_SMM_BUILDOPTS");
                const char *const env_atomics = getenv("OPENCL_LIBSMM_SMM_ATOMICS");
                const char *atomics = NULL;
                if (NULL == env_atomics || '0' != *env_atomics) {
                  if ((NULL == env_atomics && nonvcl) || NULL != c_dbcsr_acc_opencl_stristr(env_atomics, "cmpxchg")) {
                    atomics = "atomic_add_global_cmpxchg(A,B)";
                  }
                  else {
                    atomics = "atomic_add_global_xchg(A,B)";
                  }
                }
                else {
                  atomics = "*(A)+=(B)";
                }
                assert(1 <= bs && 0 < bm && 0 < bn && NULL != atomics);
                nchar = ACC_OPENCL_SNPRINTF(build_options, sizeof(build_options),
                  "%s -cl-fast-relaxed-math -cl-no-signed-zeros -cl-denorms-are-zero"
                  " -DGLOBAL=%s -DFN=%s -DSM=%i -DSN=%i -DSK=%i -DBM=%i -DBN=%i -DBS=%i"
                  " -DT=%s -DTA=%s -DFMA=fma -DCMPXCHG=%s -DXCHG=%s"
                  " -D\"ATOMIC_ADD_GLOBAL(A,B)=%s\"",
                  (NULL == env_options || '\0' == *env_options) ? "" : env_options,
                  EXIT_SUCCESS != opencl_libsmm_use_cmem(active_device) ? "global" : "constant",
                  fname, m_max, n_max, k_max, bm, bn, bs, typename,
                  atomic_type, atomic_cmpxchg, atomic_xchg, atomics);
                if (0 >= nchar || (int)sizeof(build_options) <= nchar) result = EXIT_FAILURE;
              }
              else {
                result = EXIT_FAILURE;
                ACC_OPENCL_ERROR("matrix-size causes too large WG-size", result);
              }
            }
            if (EXIT_SUCCESS == result) {
              opencl_libsmm_smm_t new_config;
#if defined(OPENCL_LIBSMM_SOURCE_MULTIPLY)
              result = c_dbcsr_acc_opencl_kernel(
                nonvcl  ? (OPENCL_LIBSMM_SOURCE_MULTIPLY)
                        : ("#pragma OPENCL EXTENSION all: enable\n"
                           OPENCL_LIBSMM_STRING_MULTIPLY),
                build_options, fname, &new_config.kernel);
#else
              result = EXIT_FAILURE;
#endif
              if (EXIT_SUCCESS == result) {
                result = c_dbcsr_acc_opencl_wgsize(active_device, new_config.kernel,
                  &max_wgsize, NULL/*preferred_multiple*/);
                if (EXIT_SUCCESS == result) {
                  assert(0 < wgsize && 0 < max_wgsize);
                  /* check planned WG-size against kernel-specific WG-size */
                  if (wgsize <= max_wgsize) {
                    const int default_params = (NULL == config ? 1 : 0);
                    if (default_params) {
                      config = (opencl_libsmm_smm_t*)OPENCL_LIBSMM_REGISTER(
                        &key, sizeof(key), sizeof(new_config), &new_config);
                    }
                    if (NULL != config) {
                      config->wgsize = (size_t)wgsize;
                      config->bs = bs; config->bm = bm; config->bn = bn;
                      config->kernel = new_config.kernel;
                      if (1 < c_dbcsr_acc_opencl_options.verbosity || 0 > c_dbcsr_acc_opencl_options.verbosity) {
                        const double duration = libxsmm_timer_duration(start, libxsmm_timer_tick());
                        fprintf(stderr, "INFO ACC/OpenCL: %ix%ix%i %sSMM-kernel generated in %.1f ms\n",
                          m_max, n_max, k_max, default_params ? "" : "tuned ", 1000.0 * duration);
                      }
                    }
                    else { /* failed to register config */
                      result = EXIT_FAILURE;
                    }
                  }
                  else {
                    result = EXIT_FAILURE;
                    ACC_OPENCL_ERROR("tile-size causes too large WG-size", result);
                  }
                }
              }
            }
          }
          else {
            result = EXIT_FAILURE;
            ACC_OPENCL_ERROR("insufficient device capabilities", result);
          }
        }
      }
      else {
        result = EXIT_FAILURE;
      }
      /* remove configuration from registry to avoid infinitely retrying code generation */
      if (EXIT_SUCCESS != result && NULL != config) {
        libxsmm_xrelease(&key, sizeof(key));
      }
    }
    assert(EXIT_SUCCESS != result || /* otherwise config must be valid */
      (NULL != config && NULL != config->kernel
        && 1 <= config->bs && 0 < config->bm && 0 < config->bn
        && 0 < config->wgsize));
    if (EXIT_SUCCESS == result) {
      /* adjust overall stacksize according to intra-kernel batchsize */
      const size_t work_size = ((stack_size + config->bs - 1) / config->bs) * config->wgsize;
#if defined(OPENCL_LIBSMM_DEBUG_SMM)
      char *ainp = NULL, *binp = NULL, *cinp = NULL, *test = NULL, *gold = NULL, *btrn = NULL;
      const libxsmm_gemm_precision precision = (dbcsr_type_real_8 == datatype
        ? LIBXSMM_GEMM_PRECISION_F64 : (dbcsr_type_real_4 == datatype ? LIBXSMM_GEMM_PRECISION_F32
        : (libxsmm_gemm_precision)LIBXSMM_DATATYPE_UNSUPPORTED));
      const int typesize = (dbcsr_type_real_8 == datatype ? 8
        : (dbcsr_type_real_4 == datatype ? 4 : 0/*unknown*/));
      size_t asize, bsize, csize;
      libxsmm_xmmfunction kernel = { NULL };
      if (  CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_a_data),
              CL_MEM_SIZE, sizeof(size_t), &asize, NULL)
        &&  CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_b_data),
              CL_MEM_SIZE, sizeof(size_t), &bsize, NULL)
        &&  CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_c_data),
              CL_MEM_SIZE, sizeof(size_t), &csize, NULL))
      {
        const double alpha = 1, beta = 1;
        libxsmm_descriptor_blob blob;
        libxsmm_gemm_descriptor *const desc = libxsmm_gemm_descriptor_dinit(&blob,
          precision, m_max, n_max, k_max, m_max, k_max, m_max, alpha, beta,
          LIBXSMM_GEMM_FLAG_NONE, LIBXSMM_PREFETCH_NONE);
        ainp = (char*)libxsmm_aligned_scratch(asize, 0/*auto-align*/);
        binp = (char*)libxsmm_aligned_scratch(bsize, 0/*auto-align*/);
        test = (char*)libxsmm_aligned_scratch(csize, 0/*auto-align*/);
        gold = (char*)libxsmm_aligned_scratch(csize, 0/*auto-align*/);
        btrn = (char*)libxsmm_aligned_scratch(k_max * n_max * typesize, 0/*auto-align*/);
        if (NULL != desc && NULL != ainp && NULL != binp && NULL != test && NULL != gold && NULL != btrn) {
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_a_data, ainp, asize, stream),
            "transfer debug a-data", result);
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_b_data, binp, bsize, stream),
            "transfer debug b-data", result);
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_c_data, gold, csize, stream),
            "transfer debug c-data", result);
          kernel = libxsmm_xmmdispatch(desc);
          assert(NULL != kernel.xmm);
        }
        else result = EXIT_FAILURE;
      }
      else result = EXIT_FAILURE;
#endif
      assert(!(OPENCL_LIBSMM_NLOCKS_SMM & (OPENCL_LIBSMM_NLOCKS_SMM - 1))); /* POT */
      { /* OpenCL is thread-safe except for clSetKernelArg and launching such shared kernel */
        const unsigned int hash = libxsmm_hash(&config->kernel, sizeof(cl_kernel), 25071975/*seed*/);
        volatile int *const lock = opencl_libsmm_lock_smm + LIBXSMM_MOD2(hash, OPENCL_LIBSMM_NLOCKS_SMM);
        LIBXSMM_ATOMIC_ACQUIRE(lock, LIBXSMM_SYNC_NPAUSE, LIBXSMM_ATOMIC_RELAXED);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 0, sizeof(cl_mem), ACC_OPENCL_MEM(dev_c_data)),
          "set C-matrix argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 1, sizeof(cl_mem), ACC_OPENCL_MEM(dev_a_data)),
          "set A-matrix argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 2, sizeof(cl_mem), ACC_OPENCL_MEM(dev_b_data)),
          "set B-matrix argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 3, sizeof(cl_mem), ACC_OPENCL_MEM(dev_param_stack)),
          "set batch-list argument of SMM-kernel", result);
        if (1 < config->bs) {
          ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 4, sizeof(int), &stack_size),
            "set stacksize argument of SMM-kernel", result);
        }
        ACC_OPENCL_CHECK(clEnqueueNDRangeKernel(*ACC_OPENCL_STREAM(stream),
          config->kernel, 1/*work_dim*/, NULL, &work_size, &config->wgsize, 0, NULL, NULL),
          "launch SMM-kernel", result);
        LIBXSMM_ATOMIC_RELEASE(lock, LIBXSMM_ATOMIC_RELAXED);
      }
#if defined(OPENCL_LIBSMM_DEBUG_SMM)
      ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_c_data, test, csize, stream),
        "transfer debug test", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_SMM) || defined(OPENCL_LIBSMM_SYNC)
      ACC_OPENCL_CHECK(acc_stream_sync(stream), "sync stream", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_SMM)
      if (EXIT_SUCCESS == result) {
        const char *const env_tol = getenv("OPENCL_LIBSMM_SMM_TOLERANCE");
        const double tolerance = ((NULL == env_tol || '\0' == *env_tol) ? 1E-3 : atof(env_tol));
        const int *const params = host_param_stack + (4 <= nparams ? (nparams - 4) : 0);
        size_t i;
        fprintf(stderr, "libsmm_acc_process(size=%i, type=%s, m=%i, n=%i, k=%i, max=%i, stream=%p)", stack_size,
          dbcsr_type_real_8 == datatype ? "f64" : (dbcsr_type_real_4 == datatype ? "f32" : "unknown"),
          m_max, n_max, k_max, max_kernel_dim, stream);
        for (i = 0; i < ((size_t)stack_size * nparams); i += nparams) {
          const size_t ia = (size_t)(params[i+0] - 1) * typesize;
          const size_t ib = (size_t)(params[i+1] - 1) * typesize;
          const size_t ic = (size_t)(params[i+2] - 1) * typesize;
          assert(ia < asize && ib < bsize && ic < csize);
          libxsmm_otrans(btrn, binp + ib, typesize, n_max, k_max, n_max, k_max);
          kernel.xmm(ainp + ia, btrn, gold + ic);
        }
        /* some result may be validated multiple times in case of duplicated c-indexes */
        for (i = 0; i < ((size_t)stack_size * nparams); i += nparams) {
          const size_t ic = (size_t)(params[i+2] - 1) * typesize;
          libxsmm_matdiff_info diff;
          libxsmm_matdiff(&diff, (libxsmm_datatype)precision, m_max, n_max,
            gold + ic, test + ic, &m_max/*ldref*/, &m_max/*ldtst*/);
          if (tolerance < diff.normf_rel) {
# if  LIBXSMM_VERSION3(1, 16, 1) <= LIBXSMM_VERSION3(LIBXSMM_VERSION_MAJOR, \
      LIBXSMM_VERSION_MINOR, LIBXSMM_VERSION_UPDATE) && 1014 <= LIBXSMM_VERSION_PATCH
            fprintf(stderr, " => ERROR diff=%g (%g != %g)\n", diff.linf_abs, diff.v_ref, diff.v_tst);
# else
            fprintf(stderr, " => ERROR diff=%g\n", diff.linf_abs);
# endif
# if defined(_DEBUG)
            opencl_libsmm_print_matrix(stderr, "gold = ", datatype, gold + ic, m_max, n_max);
            opencl_libsmm_print_matrix(stderr, "test = ", datatype, test + ic, m_max, n_max);
            fprintf(stderr, "\n");
# endif
            result = EXIT_FAILURE; break;
          }
        }
        if (EXIT_SUCCESS == result) fprintf(stderr, " => OK\n");
      }
      libxsmm_free(ainp);
      libxsmm_free(binp);
      libxsmm_free(cinp);
      libxsmm_free(test);
      libxsmm_free(gold);
      libxsmm_free(btrn);
#elif defined(NDEBUG)
      ACC_OPENCL_UNUSED(host_param_stack);
      ACC_OPENCL_UNUSED(nparams);
#endif
    }
  }
  else if (0 < stack_size) { /* inhomogeneous, large kernel, or unsupported datatype */
    return -1; /* TODO: document result code to trigger host-fallback */
  }
  ACC_OPENCL_RETURN(result);
}

#if defined(__cplusplus)
}
#endif

#endif /*__OPENCL*/
