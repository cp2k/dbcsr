/*------------------------------------------------------------------------------------------------*
 * Copyright (C) by the DBCSR developers group - All rights reserved                              *
 * This file is part of the DBCSR library.                                                        *
 *                                                                                                *
 * For information on the license, see the LICENSE file.                                          *
 * For further information please visit https://dbcsr.cp2k.org                                    *
 * SPDX-License-Identifier: GPL-2.0+                                                              *
 *------------------------------------------------------------------------------------------------*/
#if defined(__OPENCL)
#include "opencl_libsmm.h"
/* Header opencl_kernels.h is generated by the build system using acc_opencl.sh */
#include "opencl_kernels.h"
#include <libxsmm_sync.h>
#include <assert.h>

#if LIBXSMM_VERSION3(1, 16, 1) <= LIBXSMM_VERSION3(LIBXSMM_VERSION_MAJOR, \
    LIBXSMM_VERSION_MINOR, LIBXSMM_VERSION_UPDATE) && 808 <= LIBXSMM_VERSION_PATCH
# define OPENCL_LIBSMM_REGISTER(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT) \
    libxsmm_xregister(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT, NULL/*key_hash*/)
# define OPENCL_LIBSMM_DISPATCH(KEY, KEY_SIZE) \
    libxsmm_xdispatch(KEY, KEY_SIZE, NULL/*key_hash*/)
#else
# define OPENCL_LIBSMM_REGISTER(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT) \
    libxsmm_xregister(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT)
# define OPENCL_LIBSMM_DISPATCH(KEY, KEY_SIZE) \
    libxsmm_xdispatch(KEY, KEY_SIZE)
#endif

#if !defined(OPENCL_LIBSMM_DEBUG_TRANS) && defined(OPENCL_LIBSMM_DEBUG)
# define OPENCL_LIBSMM_DEBUG_TRANS
#endif
#if !defined(OPENCL_LIBSMM_DEBUG_SMM) && defined(OPENCL_LIBSMM_DEBUG)
# define OPENCL_LIBSMM_DEBUG_SMM
#endif
#if !defined(OPENCL_LIBSMM_NLOCKS_TRANS)
# define OPENCL_LIBSMM_NLOCKS_TRANS 16
#endif
#if !defined(OPENCL_LIBSMM_NLOCKS_SMM)
# define OPENCL_LIBSMM_NLOCKS_SMM 16
#endif


#if defined(__cplusplus)
extern "C" {
#endif

volatile int opencl_libsmm_lock_trans[OPENCL_LIBSMM_NLOCKS_TRANS];
volatile int opencl_libsmm_lock_smm[OPENCL_LIBSMM_NLOCKS_SMM];


int libsmm_acc_init(void)
{
#if !defined(__DBCSR_ACC)
  /* DBCSR may call acc_init() as well as libsmm_acc_init() since both interface are used.
   * libsmm_acc_init may privately call acc_init (as it depends on the ACC interface).
   * The implementation of acc_init() should be safe against "over initialization".
   * However, DBCSR only calls acc_init() and expects an implicit libsmm_acc_init().
   */
  ACC_OPENCL_RETURN(acc_init());
#else
  /* avoid recursion */
  return EXIT_SUCCESS;
#endif
}


int libsmm_acc_finalize(void)
{
  /* acc_finalize() is not called since it can be used independently  */
  return EXIT_SUCCESS;
}


acc_bool_t libsmm_acc_is_thread_safe(void)
{
  /* match DBCSR's threading level */
#if defined(_OPENMP)
  return 1;
#else
  return 0;
#endif
}


#if defined(OPENCL_LIBSMM_DEBUG) && defined(_DEBUG)
static void opencl_libsmm_print_matrix(FILE* ostream, const char* label, libsmm_acc_data_t type, const void* mat, int m, int n);
static void opencl_libsmm_print_matrix(FILE* ostream, const char* label, libsmm_acc_data_t type, const void* mat, int m, int n)
{
  int i, j;
  const char *const s = (NULL != label ? label : "");
  const int len = (int)strlen(s);
  for (i = 0; i < m; ++i) {
    if (0 < i) fprintf(ostream, "%*s", len, " "); else fprintf(ostream, "%s", s);
    for (j = 0; j < n; ++j) {
      switch (type) {
        case dbcsr_type_real_8: fprintf(ostream, "%.2f ", ((double*)mat)[i*n+j]); break;
        case dbcsr_type_real_4: fprintf(ostream, "%.2f ", ((float*) mat)[i*n+j]); break;
        default: fprintf(ostream, "? ");
      }
    }
    fprintf(ostream, "\n");
  }
}
#endif


int libsmm_acc_transpose(const int* dev_trs_stack, int offset, int stack_size,
  void* dev_data, libsmm_acc_data_t datatype, int m, int n, int max_kernel_dim, void* stream)
{
  const int mn = m * n;
  int result = EXIT_SUCCESS;
  assert((NULL != dev_trs_stack && NULL != dev_data && 0 <= offset && 0 <= stack_size) || 0 == stack_size);
  if ((
#if defined(OPENCL_LIBSMM_F64)
      dbcsr_type_real_8 == datatype
#else
      0
#endif
      ||
#if defined(OPENCL_LIBSMM_F32)
      dbcsr_type_real_4 == datatype
#else
      0
#endif
    ) &&
    0 < stack_size && 1 < mn && m <= max_kernel_dim && n <= max_kernel_dim)
  {
    typedef struct config_t {
      cl_kernel kernel;
      size_t wgsize;
    } config_t;
    struct { int m, n; libsmm_acc_data_t type; } key;
    config_t *config;
    memset(&key, 0, sizeof(key)); /* heterogeneous key-data */
    key.m = m; key.n = n; key.type = datatype; /* initialize key */
    config = (config_t*)OPENCL_LIBSMM_DISPATCH(&key, sizeof(key));
    if (NULL == config) {
      char build_options[ACC_OPENCL_BUFFERSIZE], fname[32];
      const char *const env_options = getenv("OPENCL_LIBSMM_TRANS_BUILDOPTS");
      int nchar = ACC_OPENCL_SNPRINTF(fname, sizeof(fname), "xtrans%ix%i", m, n);
      const char* typename = "";
      switch (datatype) {
        case dbcsr_type_real_8: {
          typename = "char8"; /* double */
          fname[0] = 'd';
        } break;
        case dbcsr_type_real_4: {
          typename = "float";
          fname[0] = 's';
        } break;
        default: ;
      }
      nchar = ((0 < nchar && (int)sizeof(fname) > nchar)
        ? ACC_OPENCL_SNPRINTF(build_options, sizeof(build_options), "%s -DT=%s -DFN=%s -DSM=%i -DSN=%i",
        (NULL == env_options || '\0' == *env_options) ? "" : env_options, typename, fname, m, n) : 0);
      if ('\0' != *typename && 0 < nchar && (int)sizeof(build_options) > nchar) {
        cl_device_id active_device;
        const char *const env_inplace = getenv("OPENCL_LIBSMM_TRANS_INPLACE");
#if defined(OPENCL_LIBSMM_TRANS_INPLACE)
        const int inplace = (m == n);
#else
        const int inplace = (m == n) && ((NULL == env_inplace || '\0' == *env_inplace)
          ? (EXIT_SUCCESS == acc_opencl_device(stream, &active_device) &&
             EXIT_SUCCESS == acc_opencl_device_vendor(active_device, "intel"))
          : ('0' != *env_inplace));
#endif
        config_t new_config;
#if defined(OPENCL_SOURCE_TRANSPOSE) && defined(OPENCL_SOURCE_TRANSPOSE_INPLACE)
        result = acc_opencl_kernel(
          inplace ? OPENCL_SOURCE_TRANSPOSE_INPLACE : OPENCL_SOURCE_TRANSPOSE,
          build_options, fname, &new_config.kernel);
#else
        result = EXIT_FAILURE;
#endif
        if (EXIT_SUCCESS == result) {
          int max_wgsize;
          result = acc_opencl_wgsize(new_config.kernel, NULL/*preferred_multiple*/, &max_wgsize);
          if (EXIT_SUCCESS == result) {
            const char *const env_wgsize = getenv("OPENCL_LIBSMM_TRANS_WGSIZE");
            assert(0 < max_wgsize);
            if (NULL == env_wgsize || '\0' == *env_wgsize) {
              new_config.wgsize = (size_t)m;
            }
            else {
              const int int_wgsize = atoi(env_wgsize);
              new_config.wgsize = (size_t)((m <= int_wgsize || 0 == (m % int_wgsize)) ? int_wgsize : m);
            }
            if (max_wgsize < (int)new_config.wgsize) new_config.wgsize = 1;
            config = (config_t*)OPENCL_LIBSMM_REGISTER(&key, sizeof(key),
              sizeof(new_config), &new_config);
          }
        }
      }
      else {
        result = EXIT_FAILURE;
      }
    }
    assert((NULL != config && NULL != config->kernel && 0 < config->wgsize) || EXIT_SUCCESS != result);
    if (EXIT_SUCCESS == result) {
      const size_t work_size = config->wgsize * stack_size;
#if defined(OPENCL_LIBSMM_DEBUG_TRANS)
      const int offset_stack_size = offset + stack_size;
      int *const stack = (int*)libxsmm_aligned_scratch(sizeof(int) * offset_stack_size, 0/*auto-align*/);
      char *imat = NULL, *omat = NULL, *gold = NULL;
      const int typesize = (dbcsr_type_real_8 == datatype ? 8
        : (dbcsr_type_real_4 == datatype ? 4 : 0/*unknown*/));
      size_t data_size;
      if (NULL != stack && CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_data),
        CL_MEM_SIZE, sizeof(size_t), &data_size, NULL))
      {
        imat = (char*)libxsmm_aligned_scratch(data_size, 0/*auto-align*/);
        omat = (char*)libxsmm_aligned_scratch(data_size, 0/*auto-align*/);
        gold = (char*)libxsmm_aligned_scratch(mn * typesize, 0/*auto-align*/);
        if (NULL != imat && NULL != omat && NULL != gold) {
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_trs_stack, stack, sizeof(int) * offset_stack_size, stream),
            "transfer debug stack", result);
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_data, imat, data_size, stream),
            "transfer debug input", result);
        }
        else result = EXIT_FAILURE;
      }
      else result = EXIT_FAILURE;
#endif
      assert(!(OPENCL_LIBSMM_NLOCKS_TRANS & (OPENCL_LIBSMM_NLOCKS_TRANS - 1))); /* POT */
      { /* OpenCL is thread-safe except for clSetKernelArg and launching such shared kernel */
        const unsigned int hash = libxsmm_hash(&config->kernel, sizeof(cl_kernel), 25071975/*seed*/);
        volatile int *const lock = opencl_libsmm_lock_trans + LIBXSMM_MOD2(hash, OPENCL_LIBSMM_NLOCKS_TRANS);
        LIBXSMM_ATOMIC_ACQUIRE(lock, LIBXSMM_SYNC_NPAUSE, LIBXSMM_ATOMIC_RELAXED);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 0, sizeof(cl_mem), ACC_OPENCL_MEM(dev_trs_stack)),
          "set batch-list argument of transpose kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 1, sizeof(int), &offset),
          "set offset argument of transpose kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 2, sizeof(cl_mem), ACC_OPENCL_MEM(dev_data)),
          "set matrix-data argument of transpose kernel", result);
        ACC_OPENCL_CHECK(clEnqueueNDRangeKernel(*ACC_OPENCL_STREAM(stream),
          config->kernel, 1/*work_dim*/, NULL, &work_size, &config->wgsize, 0, NULL, NULL),
          "launch transpose kernel", result);
        LIBXSMM_ATOMIC_RELEASE(lock, LIBXSMM_ATOMIC_RELAXED);
      }
#if defined(OPENCL_LIBSMM_DEBUG_TRANS)
      ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_data, omat, data_size, stream),
        "transfer debug test", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_TRANS) || defined(OPENCL_LIBSMM_SYNC)
      ACC_OPENCL_CHECK(acc_stream_sync(stream), "sync stream", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_TRANS)
      if (EXIT_SUCCESS == result) {
        int i, j;
        fprintf(stderr, "libsmm_acc_transpose("
          "offset=%i, size=%i, type=%s, m=%i, n=%i, max=%i, stream=%p)", offset, stack_size,
          dbcsr_type_real_8 == datatype ? "f64" : (dbcsr_type_real_4 == datatype ? "f32" : "unknown"),
          m, n, max_kernel_dim, stream);
        for (i = offset; i < offset_stack_size; ++i) {
          const size_t index = stack[i];
          const char *const orig = imat + index * typesize;
          const char *const test = omat + index * typesize;
          assert((index * typesize) < data_size);
          memcpy(gold, orig, mn * typesize);
          libxsmm_itrans(gold, typesize, m, n, m, n);
          if (0 != memcmp(gold, test, mn * typesize)) {
            fprintf(stderr, " => ERROR\n");
# if defined(_DEBUG)
            opencl_libsmm_print_matrix(stderr, "orig = ", datatype, orig, m, n);
            opencl_libsmm_print_matrix(stderr, "gold = ", datatype, gold, n, m);
            opencl_libsmm_print_matrix(stderr, "test = ", datatype, test, n, m);
            fprintf(stderr, "\n");
# endif
            result = EXIT_FAILURE; break;
          }
          for (j = offset; j < i; ++j) {
            const size_t duplicate = stack[j];
            if (index == duplicate) {
              fprintf(stderr, " => ERROR\n");
              result = EXIT_FAILURE;
              i = offset_stack_size;
              break;
            }
          }
        }
        if (EXIT_SUCCESS == result) fprintf(stderr, " => OK\n");
      }
      libxsmm_free(stack);
      libxsmm_free(imat);
      libxsmm_free(omat);
      libxsmm_free(gold);
#endif
    }
  }
  ACC_OPENCL_RETURN(result);
}


int libsmm_acc_process(const int* host_param_stack, const int* dev_param_stack, int stack_size,
  int nparams, libsmm_acc_data_t datatype, const void* dev_a_data, const void* dev_b_data, void* dev_c_data,
  int m_max, int n_max, int k_max, int max_kernel_dim, acc_bool_t def_mnk, void* stack_stream, void* c_stream)
{
  int result = EXIT_SUCCESS;
  ACC_OPENCL_UNUSED(c_stream); /* TODO */
  assert(0 == stack_size || (NULL != host_param_stack && NULL != dev_param_stack
    && NULL != dev_a_data && NULL != dev_b_data && NULL != dev_c_data));
  assert(0 < nparams && 0 < max_kernel_dim && NULL != stack_stream);
  assert(0 <= stack_size && 0 <= m_max && 0 <= n_max && 0 <= k_max);
  if ((
#if defined(OPENCL_LIBSMM_F64)
      dbcsr_type_real_8 == datatype
#else
      0
#endif
      ||
#if defined(OPENCL_LIBSMM_F32)
      dbcsr_type_real_4 == datatype
#else
      0
#endif
    ) &&
    0 < stack_size && def_mnk/*homogeneous*/ &&
    0 < m_max && m_max <= max_kernel_dim &&
    0 < n_max && n_max <= max_kernel_dim &&
    0 < k_max && k_max <= max_kernel_dim)
  {
    typedef struct config_t {
      cl_kernel kernel;
    } config_t;
    struct { int m, n, k; libsmm_acc_data_t type; } key;
    config_t *config;
    memset(&key, 0, sizeof(key)); /* heterogeneous key-data */
    key.m = m_max; key.n = n_max; key.k = k_max; key.type = datatype; /* initialize key */
    config = (config_t*)OPENCL_LIBSMM_DISPATCH(&key, sizeof(key));
    if (NULL == config) {
      char build_options[ACC_OPENCL_BUFFERSIZE], fname[48];
      int nchar = ACC_OPENCL_SNPRINTF(fname, sizeof(fname), "xmm%ix%ix%i", m_max, n_max, k_max);
      const char* extensions = NULL;
      if (0 < nchar && (int)sizeof(fname) > nchar) {
        cl_device_id active_device;
        result = acc_opencl_device(stack_stream, &active_device);
        if (EXIT_SUCCESS == result) {
          const char *const env_options = getenv("OPENCL_LIBSMM_SMM_BUILDOPTS");
          const char *typename = NULL, *atomic_t = NULL, *atomic_f = NULL;
          assert(NULL != active_device);
          switch (datatype) {
            case dbcsr_type_real_8: {
              extensions = "cl_khr_fp64 cl_khr_int64_base_atomics";
              if (EXIT_SUCCESS == acc_opencl_device_ext(active_device, &extensions, 1)) {
                typename = "double";
                atomic_t = "long";
                atomic_f = "atom_cmpxchg";
                fname[0] = 'd';
              }
            } break;
            case dbcsr_type_real_4: {
              extensions = "cl_khr_global_int32_base_atomics";
              if (EXIT_SUCCESS == acc_opencl_device_ext(active_device, &extensions, 1)) {
                typename = "float";
                atomic_t = "int";
                atomic_f = "atomic_cmpxchg";
                fname[0] = 's';
              }
            } break;
            default: ;
          }
          if (NULL != typename && '\0' != *typename) {
            const char *const build_setup =
              "%s -cl-fast-relaxed-math -cl-no-signed-zeros -cl-denorms-are-zero"
              " -DT=%s -DTA=\"%s\" -DFA=%s -DFN=%s -DSM=%i -DSN=%i -DSK=%i";
            nchar = ACC_OPENCL_SNPRINTF(build_options, sizeof(build_options), build_setup,
              (NULL == env_options || '\0' == *env_options) ? "" : env_options,
              typename, atomic_t, atomic_f, fname, m_max, n_max, k_max);
            if (0 >= nchar || (int)sizeof(build_options) <= nchar) result = EXIT_FAILURE;
          }
          else {
            result = EXIT_FAILURE;
            ACC_OPENCL_ERROR("insufficient device capabilities", result);
          }
        }
      }
      else {
        result = EXIT_FAILURE;
      }
      if (EXIT_SUCCESS == result) {
        config_t new_config;
#if defined(OPENCL_SOURCE_MULTIPLY)
        result = acc_opencl_kernel(OPENCL_SOURCE_MULTIPLY, build_options, fname, &new_config.kernel);
#else
        result = EXIT_FAILURE;
#endif
        if (EXIT_SUCCESS == result) {
          int max_wgsize;
          result = acc_opencl_wgsize(new_config.kernel, NULL/*preferred_multiple*/, &max_wgsize);
          if (EXIT_SUCCESS == result) {
            assert(0 < max_wgsize);
            if (n_max <= max_wgsize) {
              config = (config_t*)OPENCL_LIBSMM_REGISTER(&key, sizeof(key),
                sizeof(new_config), &new_config);
            }
            else result = EXIT_FAILURE;
          }
        }
      }
      else {
        result = EXIT_FAILURE;
      }
    }
    assert((NULL != config && NULL != config->kernel) || EXIT_SUCCESS != result);
    if (EXIT_SUCCESS == result) {
      const size_t wgsize = n_max, work_size = wgsize * stack_size;
#if defined(OPENCL_LIBSMM_DEBUG_SMM)
      char *ainp = NULL, *binp = NULL, *cinp = NULL, *test = NULL, *gold = NULL, *btrn = NULL;
      const libxsmm_gemm_precision precision = (dbcsr_type_real_8 == datatype
        ? LIBXSMM_GEMM_PRECISION_F64 : (dbcsr_type_real_4 == datatype ? LIBXSMM_GEMM_PRECISION_F32
        : (libxsmm_gemm_precision)LIBXSMM_DATATYPE_UNSUPPORTED));
      const int typesize = (dbcsr_type_real_8 == datatype ? 8
        : (dbcsr_type_real_4 == datatype ? 4 : 0/*unknown*/));
      size_t asize, bsize, csize;
      libxsmm_xmmfunction kernel = { NULL };
      if (  CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_a_data),
              CL_MEM_SIZE, sizeof(size_t), &asize, NULL)
        &&  CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_b_data),
              CL_MEM_SIZE, sizeof(size_t), &bsize, NULL)
        &&  CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_c_data),
              CL_MEM_SIZE, sizeof(size_t), &csize, NULL))
      {
        const double alpha = 1, beta = 1;
        libxsmm_descriptor_blob blob;
        libxsmm_gemm_descriptor *const desc = libxsmm_gemm_descriptor_dinit(&blob,
          precision, m_max, n_max, k_max, m_max, k_max, m_max, alpha, beta,
          LIBXSMM_GEMM_FLAG_NONE, LIBXSMM_PREFETCH_NONE);
        ainp = (char*)libxsmm_aligned_scratch(asize, 0/*auto-align*/);
        binp = (char*)libxsmm_aligned_scratch(bsize, 0/*auto-align*/);
        test = (char*)libxsmm_aligned_scratch(csize, 0/*auto-align*/);
        gold = (char*)libxsmm_aligned_scratch(csize, 0/*auto-align*/);
        btrn = (char*)libxsmm_aligned_scratch(k_max * n_max * typesize, 0/*auto-align*/);
        if (NULL != desc && NULL != ainp && NULL != binp && NULL != test && NULL != gold && NULL != btrn) {
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_a_data, ainp, asize, stack_stream),
            "transfer debug a-data", result);
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_b_data, binp, bsize, stack_stream),
            "transfer debug b-data", result);
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_c_data, gold, csize, stack_stream),
            "transfer debug c-data", result);
          kernel = libxsmm_xmmdispatch(desc);
          assert(NULL != kernel.xmm);
        }
        else result = EXIT_FAILURE;
      }
      else result = EXIT_FAILURE;
#endif
      assert(!(OPENCL_LIBSMM_NLOCKS_SMM & (OPENCL_LIBSMM_NLOCKS_SMM - 1))); /* POT */
      { /* OpenCL is thread-safe except for clSetKernelArg and launching such shared kernel */
        const unsigned int hash = libxsmm_hash(&config->kernel, sizeof(cl_kernel), 25071975/*seed*/);
        volatile int *const lock = opencl_libsmm_lock_smm + LIBXSMM_MOD2(hash, OPENCL_LIBSMM_NLOCKS_SMM);
        LIBXSMM_ATOMIC_ACQUIRE(lock, LIBXSMM_SYNC_NPAUSE, LIBXSMM_ATOMIC_RELAXED);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 0, sizeof(cl_mem), ACC_OPENCL_MEM(dev_param_stack)),
          "set batch-list argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 1, sizeof(cl_mem), ACC_OPENCL_MEM(dev_a_data)),
          "set A-matrix argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 2, sizeof(cl_mem), ACC_OPENCL_MEM(dev_b_data)),
          "set B-matrix argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 3, sizeof(cl_mem), ACC_OPENCL_MEM(dev_c_data)),
          "set C-matrix argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clEnqueueNDRangeKernel(*ACC_OPENCL_STREAM(stack_stream),
          config->kernel, 1/*work_dim*/, NULL, &work_size, &wgsize, 0, NULL, NULL),
          "launch SMM-kernel", result);
        LIBXSMM_ATOMIC_RELEASE(lock, LIBXSMM_ATOMIC_RELAXED);
      }
#if defined(OPENCL_LIBSMM_DEBUG_SMM)
      ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_c_data, test, csize, stack_stream),
        "transfer debug test", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_SMM) || defined(OPENCL_LIBSMM_SYNC)
      ACC_OPENCL_CHECK(acc_stream_sync(stack_stream), "sync stream", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_SMM)
      if (EXIT_SUCCESS == result) {
        const char *const env_tol = getenv("OPENCL_LIBSMM_SMM_TOLERANCE");
        const double tolerance = ((NULL == env_tol || '\0' == *env_tol) ? 1E-3 : atof(env_tol));
        const int *const params = host_param_stack + (4 <= nparams ? (nparams - 4) : 0);
        size_t i;
        fprintf(stderr, "libsmm_acc_process(size=%i, type=%s, m=%i, n=%i, k=%i, max=%i, stream=%p)", stack_size,
          dbcsr_type_real_8 == datatype ? "f64" : (dbcsr_type_real_4 == datatype ? "f32" : "unknown"),
          m_max, n_max, k_max, max_kernel_dim, stack_stream);
        for (i = 0; i < ((size_t)stack_size * nparams); i += nparams) {
          const size_t ia = (size_t)(params[i+0] - 1) * typesize;
          const size_t ib = (size_t)(params[i+1] - 1) * typesize;
          const size_t ic = (size_t)(params[i+2] - 1) * typesize;
          assert(ia < asize && ib < bsize && ic < csize);
          libxsmm_otrans(btrn, binp + ib, typesize, n_max, k_max, n_max, k_max);
          kernel.xmm(ainp + ia, btrn, gold + ic);
        }
        /* some result may be validated multiple times in case of duplicated c-indexes */
        for (i = 0; i < ((size_t)stack_size * nparams); i += nparams) {
          const size_t ic = (size_t)(params[i+2] - 1) * typesize;
          libxsmm_matdiff_info diff;
          libxsmm_matdiff(&diff, (libxsmm_datatype)precision, m_max, n_max,
            gold + ic, test + ic, &m_max/*ldref*/, &m_max/*ldtst*/);
          if (tolerance < diff.normf_rel) {
            fprintf(stderr, " => ERROR\n");
# if defined(_DEBUG)
            opencl_libsmm_print_matrix(stderr, "gold = ", datatype, gold + ic, m_max, n_max);
            opencl_libsmm_print_matrix(stderr, "test = ", datatype, test + ic, m_max, n_max);
            fprintf(stderr, "\n");
# endif
            result = EXIT_FAILURE; break;
          }
        }
        if (EXIT_SUCCESS == result) fprintf(stderr, " => OK\n");
      }
      libxsmm_free(ainp);
      libxsmm_free(binp);
      libxsmm_free(cinp);
      libxsmm_free(test);
      libxsmm_free(gold);
      libxsmm_free(btrn);
#elif defined(NDEBUG)
      ACC_OPENCL_UNUSED(host_param_stack);
      ACC_OPENCL_UNUSED(nparams);
#endif
    }
  }
  else if (0 < stack_size) { /* inhomogeneous, large kernel, or unsupported datatype */
    return -1; /* TODO: document result code to trigger host-fallback */
  }
  ACC_OPENCL_RETURN(result);
}

#if defined(__cplusplus)
}
#endif

#endif /*__OPENCL*/
