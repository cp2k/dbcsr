/*------------------------------------------------------------------------------------------------*
 * Copyright (C) by the DBCSR developers group - All rights reserved                              *
 * This file is part of the DBCSR library.                                                        *
 *                                                                                                *
 * For information on the license, see the LICENSE file.                                          *
 * For further information please visit https://dbcsr.cp2k.org                                    *
 * SPDX-License-Identifier: GPL-2.0+                                                              *
 *------------------------------------------------------------------------------------------------*/
#if defined(__OPENCL)
#include "opencl_libsmm.h"
/* Header opencl_kernels.h is generated by the build system using acc_opencl.sh */
#include "opencl_kernels.h"
#include <libxsmm_sync.h>
#include <assert.h>

#if LIBXSMM_VERSION3(1, 16, 1) <= LIBXSMM_VERSION3(LIBXSMM_VERSION_MAJOR, \
    LIBXSMM_VERSION_MINOR, LIBXSMM_VERSION_UPDATE) && 808 <= LIBXSMM_VERSION_PATCH
# define OPENCL_LIBSMM_REGISTER(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT) \
    libxsmm_xregister(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT, NULL/*key_hash*/)
# define OPENCL_LIBSMM_DISPATCH(KEY, KEY_SIZE) \
    libxsmm_xdispatch(KEY, KEY_SIZE, NULL/*key_hash*/)
#else
# define OPENCL_LIBSMM_REGISTER(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT) \
    libxsmm_xregister(KEY, KEY_SIZE, VALUE_SIZE, VALUE_INIT)
# define OPENCL_LIBSMM_DISPATCH(KEY, KEY_SIZE) \
    libxsmm_xdispatch(KEY, KEY_SIZE)
#endif

#if !defined(OPENCL_LIBSMM_DEBUG_TRANS) && defined(OPENCL_LIBSMM_DEBUG)
# define OPENCL_LIBSMM_DEBUG_TRANS
#endif
#if !defined(OPENCL_LIBSMM_DEBUG_SMM) && defined(OPENCL_LIBSMM_DEBUG)
# define OPENCL_LIBSMM_DEBUG_SMM
#endif
#if !defined(OPENCL_LIBSMM_NLOCKS_TRANS)
# define OPENCL_LIBSMM_NLOCKS_TRANS 16
#endif
#if !defined(OPENCL_LIBSMM_NLOCKS_SMM)
# define OPENCL_LIBSMM_NLOCKS_SMM 16
#endif


#if defined(__cplusplus)
extern "C" {
#endif

volatile int opencl_libsmm_lock_trans[OPENCL_LIBSMM_NLOCKS_TRANS];
volatile int opencl_libsmm_lock_smm[OPENCL_LIBSMM_NLOCKS_SMM];


int opencl_libsmm_use_cmem(cl_device_id device)
{
#if defined(OPENCL_LIBSMM_CMEM)
  int result = EXIT_SUCCESS;
  cl_ulong size_maxalloc = 1, size_maxcmem = 0;
  ACC_OPENCL_CHECK(clGetDeviceInfo(device, CL_DEVICE_MAX_MEM_ALLOC_SIZE,
    sizeof(cl_ulong), &size_maxalloc, NULL), "retrieve maximum size of memory allocation", result);
  ACC_OPENCL_CHECK(clGetDeviceInfo(device, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE,
    sizeof(cl_ulong), &size_maxcmem, NULL), "retrieve maximum size of constant buffer", result);
  return (EXIT_SUCCESS == result ? (size_maxalloc <= size_maxcmem ? EXIT_SUCCESS : EXIT_FAILURE) : result);
#else
  ACC_OPENCL_UNUSED(device);
  return EXIT_FAILURE;
#endif
}


#if defined(OPENCL_LIBSMM_DEBUG) && defined(_DEBUG)
static void opencl_libsmm_print_matrix(FILE* ostream, const char* label, libsmm_acc_data_t type, const void* mat, int m, int n)
{
  int i, j;
  const char *const s = (NULL != label ? label : "");
  const int len = (int)strlen(s);
  for (i = 0; i < m; ++i) {
    if (0 < i) fprintf(ostream, "%*s", len, " "); else fprintf(ostream, "%s", s);
    for (j = 0; j < n; ++j) {
      switch (type) {
        case dbcsr_type_real_8: fprintf(ostream, "%.2f ", ((double*)mat)[i*n+j]); break;
        case dbcsr_type_real_4: fprintf(ostream, "%.2f ", ((float*) mat)[i*n+j]); break;
        default: fprintf(ostream, "? ");
      }
    }
    fprintf(ostream, "\n");
  }
}
#endif


int libsmm_acc_init(void)
{
#if !defined(__DBCSR_ACC)
  /* DBCSR may call acc_init() as well as libsmm_acc_init() since both interface are used.
   * libsmm_acc_init may privately call acc_init (as it depends on the ACC interface).
   * The implementation of acc_init() should be safe against "over initialization".
   * However, DBCSR only calls acc_init() and expects an implicit libsmm_acc_init().
   */
  ACC_OPENCL_RETURN(acc_init());
#else
  /* avoid recursion */
  return EXIT_SUCCESS;
#endif
}


int libsmm_acc_finalize(void)
{
  /* acc_finalize() is not called since it can be used independently  */
  return EXIT_SUCCESS;
}


acc_bool_t libsmm_acc_is_thread_safe(void)
{
  /* match DBCSR's threading level */
#if defined(_OPENMP)
  return 1;
#else
  return 0;
#endif
}


int libsmm_acc_transpose(const int* dev_trs_stack, int offset, int stack_size,
  void* dev_data, libsmm_acc_data_t datatype, int m, int n, int max_kernel_dim, void* stream)
{
  const int mn = m * n;
  int result = EXIT_SUCCESS;
  assert((NULL != dev_trs_stack && NULL != dev_data && 0 <= offset && 0 <= stack_size) || 0 == stack_size);
  if ((
#if defined(OPENCL_LIBSMM_F64)
      dbcsr_type_real_8 == datatype
#else
      0
#endif
      ||
#if defined(OPENCL_LIBSMM_F32)
      dbcsr_type_real_4 == datatype
#else
      0
#endif
    ) &&
    0 < stack_size && 1 < mn && m <= max_kernel_dim && n <= max_kernel_dim)
  {
    typedef struct config_t {
      cl_kernel kernel;
      size_t wgsize;
    } config_t;
    struct { int m, n; libsmm_acc_data_t type; } key;
    config_t *config;
    memset(&key, 0, sizeof(key)); /* heterogeneous key-data */
    key.m = m; key.n = n; key.type = datatype; /* initialize key */
    config = (config_t*)OPENCL_LIBSMM_DISPATCH(&key, sizeof(key));
    if (NULL == config) {
      char build_options[ACC_OPENCL_BUFFERSIZE], fname[32];
      int nchar = ACC_OPENCL_SNPRINTF(fname, sizeof(fname), "xtrans%ix%i", m, n);
      if (0 < nchar && (int)sizeof(fname) > nchar) {
        cl_device_id active_device;
        result = acc_opencl_device(stream, &active_device);
        if (EXIT_SUCCESS == result) {
          const char *const env_options = getenv("OPENCL_LIBSMM_TRANS_BUILDOPTS");
          const char *const env_wgsize = getenv("OPENCL_LIBSMM_TRANS_WGSIZE");
          const char* typename = "";
          int wgsize;
          switch (datatype) {
            case dbcsr_type_real_8: {
              typename = "char8"; /* double */
              fname[0] = 'd';
            } break;
            case dbcsr_type_real_4: {
              typename = "float";
              fname[0] = 's';
            } break;
            default: ;
          }
          if (NULL == env_wgsize || '\0' == *env_wgsize) {
            wgsize = m;
          }
          else {
            wgsize = atoi(env_wgsize);
            wgsize = ((m <= wgsize || 0 == (m % wgsize)) ? wgsize : m);
          }
          nchar = ACC_OPENCL_SNPRINTF(build_options, sizeof(build_options), "%s"
            " -DGLOBAL=%s -DFN=%s -DSM=%i -DSN=%i -DSWG=%i -DT=%s",
            (NULL == env_options || '\0' == *env_options) ? "" : env_options,
            EXIT_SUCCESS != opencl_libsmm_use_cmem(active_device) ? "global" : "constant",
            fname, m, n, wgsize, typename);
          if ('\0' != *typename && 0 < nchar && (int)sizeof(build_options) > nchar) {
            const char *const env_inplace = getenv("OPENCL_LIBSMM_TRANS_INPLACE");
#if defined(OPENCL_LIBSMM_TRANS_INPLACE)
            const int inplace = (m == n);
#else
            const int inplace = (m == n) && ((NULL == env_inplace || '\0' == *env_inplace)
              ? (EXIT_SUCCESS == acc_opencl_device_vendor(active_device, "intel"))
              : ('0' != *env_inplace));
#endif
            if (EXIT_SUCCESS == result) {
              config_t new_config;
#if defined(OPENCL_SOURCE_TRANSPOSE) && defined(OPENCL_SOURCE_TRANSPOSE_INPLACE)
              result = acc_opencl_kernel(
                inplace ? OPENCL_SOURCE_TRANSPOSE_INPLACE : OPENCL_SOURCE_TRANSPOSE,
                build_options, fname, &new_config.kernel);
#else
              result = EXIT_FAILURE;
#endif
              if (EXIT_SUCCESS == result) {
                int max_wgsize;
                result = acc_opencl_wgsize(active_device, new_config.kernel,
                  &max_wgsize, NULL/*preferred_multiple*/);
                if (EXIT_SUCCESS == result) {
                  assert(0 < max_wgsize);
                  if (wgsize <= max_wgsize) {
                    new_config.wgsize = (size_t)wgsize;
                    config = (config_t*)OPENCL_LIBSMM_REGISTER(&key, sizeof(key),
                      sizeof(new_config), &new_config);
                  }
                  else result = EXIT_FAILURE;
                }
              }
            }
          }
          else {
            result = EXIT_FAILURE;
          }
        }
      }
      else {
        result = EXIT_FAILURE;
      }
    }
    assert((NULL != config && NULL != config->kernel && 0 < config->wgsize) || EXIT_SUCCESS != result);
    if (EXIT_SUCCESS == result) {
      const size_t work_size = config->wgsize * stack_size;
#if defined(OPENCL_LIBSMM_DEBUG_TRANS)
      const int offset_stack_size = offset + stack_size;
      int *const stack = (int*)libxsmm_aligned_scratch(sizeof(int) * offset_stack_size, 0/*auto-align*/);
      char *imat = NULL, *omat = NULL, *gold = NULL;
      const int typesize = (dbcsr_type_real_8 == datatype ? 8
        : (dbcsr_type_real_4 == datatype ? 4 : 0/*unknown*/));
      size_t data_size;
      if (NULL != stack && CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_data),
        CL_MEM_SIZE, sizeof(size_t), &data_size, NULL))
      {
        imat = (char*)libxsmm_aligned_scratch(data_size, 0/*auto-align*/);
        omat = (char*)libxsmm_aligned_scratch(data_size, 0/*auto-align*/);
        gold = (char*)libxsmm_aligned_scratch(mn * typesize, 0/*auto-align*/);
        if (NULL != imat && NULL != omat && NULL != gold) {
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_trs_stack, stack, sizeof(int) * offset_stack_size, stream),
            "transfer debug stack", result);
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_data, imat, data_size, stream),
            "transfer debug input", result);
        }
        else result = EXIT_FAILURE;
      }
      else result = EXIT_FAILURE;
#endif
      assert(!(OPENCL_LIBSMM_NLOCKS_TRANS & (OPENCL_LIBSMM_NLOCKS_TRANS - 1))); /* POT */
      { /* OpenCL is thread-safe except for clSetKernelArg and launching such shared kernel */
        const unsigned int hash = libxsmm_hash(&config->kernel, sizeof(cl_kernel), 25071975/*seed*/);
        volatile int *const lock = opencl_libsmm_lock_trans + LIBXSMM_MOD2(hash, OPENCL_LIBSMM_NLOCKS_TRANS);
        LIBXSMM_ATOMIC_ACQUIRE(lock, LIBXSMM_SYNC_NPAUSE, LIBXSMM_ATOMIC_RELAXED);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 0, sizeof(cl_mem), ACC_OPENCL_MEM(dev_trs_stack)),
          "set batch-list argument of transpose kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 1, sizeof(int), &offset),
          "set offset argument of transpose kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 2, sizeof(cl_mem), ACC_OPENCL_MEM(dev_data)),
          "set matrix-data argument of transpose kernel", result);
        ACC_OPENCL_CHECK(clEnqueueNDRangeKernel(*ACC_OPENCL_STREAM(stream),
          config->kernel, 1/*work_dim*/, NULL, &work_size, &config->wgsize, 0, NULL, NULL),
          "launch transpose kernel", result);
        LIBXSMM_ATOMIC_RELEASE(lock, LIBXSMM_ATOMIC_RELAXED);
      }
#if defined(OPENCL_LIBSMM_DEBUG_TRANS)
      ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_data, omat, data_size, stream),
        "transfer debug test", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_TRANS) || defined(OPENCL_LIBSMM_SYNC)
      ACC_OPENCL_CHECK(acc_stream_sync(stream), "sync stream", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_TRANS)
      if (EXIT_SUCCESS == result) {
        int i, j;
        fprintf(stderr, "libsmm_acc_transpose("
          "offset=%i, size=%i, type=%s, m=%i, n=%i, max=%i, stream=%p)", offset, stack_size,
          dbcsr_type_real_8 == datatype ? "f64" : (dbcsr_type_real_4 == datatype ? "f32" : "unknown"),
          m, n, max_kernel_dim, stream);
        for (i = offset; i < offset_stack_size; ++i) {
          const size_t index = stack[i];
          const char *const orig = imat + index * typesize;
          const char *const test = omat + index * typesize;
          assert((index * typesize) < data_size);
          memcpy(gold, orig, mn * typesize);
          libxsmm_itrans(gold, typesize, m, n, m, n);
          if (0 != memcmp(gold, test, mn * typesize)) {
            fprintf(stderr, " => ERROR\n");
# if defined(_DEBUG)
            opencl_libsmm_print_matrix(stderr, "orig = ", datatype, orig, m, n);
            opencl_libsmm_print_matrix(stderr, "gold = ", datatype, gold, n, m);
            opencl_libsmm_print_matrix(stderr, "test = ", datatype, test, n, m);
            fprintf(stderr, "\n");
# endif
            result = EXIT_FAILURE; break;
          }
          for (j = offset; j < i; ++j) {
            const size_t duplicate = stack[j];
            if (index == duplicate) {
              fprintf(stderr, " => ERROR\n");
              result = EXIT_FAILURE;
              i = offset_stack_size;
              break;
            }
          }
        }
        if (EXIT_SUCCESS == result) fprintf(stderr, " => OK\n");
      }
      libxsmm_free(stack);
      libxsmm_free(imat);
      libxsmm_free(omat);
      libxsmm_free(gold);
#endif
    }
  }
  ACC_OPENCL_RETURN(result);
}


int libsmm_acc_process(const int* host_param_stack, const int* dev_param_stack, int stack_size,
  int nparams, libsmm_acc_data_t datatype, const void* dev_a_data, const void* dev_b_data, void* dev_c_data,
  int m_max, int n_max, int k_max, int max_kernel_dim, acc_bool_t def_mnk, void* stream, void* c_stream)
{
  int result = EXIT_SUCCESS;
  ACC_OPENCL_UNUSED(c_stream); /* TODO */
  assert(0 == stack_size || (NULL != host_param_stack && NULL != dev_param_stack
    && NULL != dev_a_data && NULL != dev_b_data && NULL != dev_c_data));
  assert(0 < nparams && 0 < max_kernel_dim && NULL != stream);
  assert(0 <= stack_size && 0 <= m_max && 0 <= n_max && 0 <= k_max);
  if ((
#if defined(OPENCL_LIBSMM_F64)
      dbcsr_type_real_8 == datatype
#else
      0
#endif
      ||
#if defined(OPENCL_LIBSMM_F32)
      dbcsr_type_real_4 == datatype
#else
      0
#endif
    ) &&
    0 < stack_size && def_mnk/*homogeneous*/ &&
    0 < m_max && m_max <= max_kernel_dim &&
    0 < n_max && n_max <= max_kernel_dim &&
    0 < k_max && k_max <= max_kernel_dim)
  {
    typedef struct config_t {
      cl_kernel kernel;
      size_t wgsize;
      int batchsize;
    } config_t;
    struct { int m, n, k; libsmm_acc_data_t type; } key;
    config_t *config;
    memset(&key, 0, sizeof(key)); /* heterogeneous key-data */
    key.m = m_max; key.n = n_max; key.k = k_max; key.type = datatype; /* initialize key */
    config = (config_t*)OPENCL_LIBSMM_DISPATCH(&key, sizeof(key));
    if (NULL == config) {
      char build_options[ACC_OPENCL_BUFFERSIZE], fname[48];
      int nchar = ACC_OPENCL_SNPRINTF(fname, sizeof(fname), "xmm%ix%ix%i", m_max, n_max, k_max);
      const char* extensions = NULL;
      if (0 < nchar && (int)sizeof(fname) > nchar) {
        cl_device_id active_device;
        result = acc_opencl_device(stream, &active_device);
        if (EXIT_SUCCESS == result) {
          const char *atomic_cmpxchg = NULL, *atomic_xchg = NULL;
          const char *atomic_type = NULL, *typename = NULL;
          assert(NULL != active_device);
          switch (datatype) {
            case dbcsr_type_real_8: {
              extensions = "cl_khr_fp64 cl_khr_int64_base_atomics";
              if (EXIT_SUCCESS == acc_opencl_device_ext(active_device, &extensions, 1)) {
                atomic_cmpxchg = "atom_cmpxchg";
                atomic_xchg = "atom_xchg";
                atomic_type = "long";
                typename = "double";
                fname[0] = 'd';
              }
            } break;
            case dbcsr_type_real_4: {
              extensions = "cl_khr_global_int32_base_atomics";
              if (EXIT_SUCCESS == acc_opencl_device_ext(active_device, &extensions, 1)) {
                atomic_cmpxchg = "atomic_cmpxchg";
                atomic_xchg = "atomic_xchg";
                atomic_type = "int";
                typename = "float";
                fname[0] = 's';
              }
            } break;
            default: ;
          }
          if (NULL != typename) {
            int max_wgsize, wgsize, bs, bm, bn, nbm, nbn;
            result = acc_opencl_wgsize(active_device, NULL/*device-specific*/,
              &max_wgsize, NULL/*preferred_multiple*/);
            if (EXIT_SUCCESS == result) {
              const char *const env_batchsize = getenv("OPENCL_LIBSMM_SMM_BATCHSIZE");
              const char *const env_blockm = getenv("OPENCL_LIBSMM_SMM_BLOCK_M");
              const char *const env_blockn = getenv("OPENCL_LIBSMM_SMM_BLOCK_N");
              /* TODO: load parameters from file (auto-tuned) */
              const int batchsize = ((NULL == env_batchsize || '\0' == *env_batchsize)
                ? 1/*TODO*/ : atoi(env_batchsize));
              const int blockm = ((NULL == env_blockm || '\0' == *env_blockm)
                ? 1/*TODO*/ : atoi(env_blockm));
              const int blockn = ((NULL == env_blockn || '\0' == *env_blockn)
                ? n_max/*TODO*/ : atoi(env_blockn));
              bm = LIBXSMM_CLMP(blockm, 1, m_max);
              bn = LIBXSMM_CLMP(blockn, 1, n_max);
              bs = LIBXSMM_MAX(batchsize, 1);
              nbm = (m_max + bm - 1) / bm;
              nbn = (n_max + bn - 1) / bn;
              wgsize = nbm * nbn;
              assert(1 <= bs && 0 < wgsize && 0 < max_wgsize);
              /* limit WG-size to device's maximum WG-size */
              while (max_wgsize < wgsize && (bm < m_max || bn < n_max)) {
                if (bn < n_max) {
                  ++bn; nbn = (n_max + bn - 1) / bn;
                }
                else if (bm < m_max) {
                  ++bm; nbm = (m_max + bm - 1) / bm;
                }
                wgsize = nbm * nbn;
              }
              if (wgsize <= max_wgsize) { /* SMMs can be potentially handled by device */
                const char *const env_options = getenv("OPENCL_LIBSMM_SMM_BUILDOPTS");
                const char *const env_atomics = getenv("OPENCL_LIBSMM_SMM_ATOMICS");
                const char *atomics = NULL;
                if (NULL == env_atomics || '0' != *env_atomics) {
                  if ((NULL == env_atomics && EXIT_SUCCESS != acc_opencl_device_vendor(active_device, "nvidia"))
                    || NULL != acc_opencl_stristr(env_atomics, "cmpxchg"))
                  {
                    atomics = "atomic_add_global_cmpxchg(A,B)";
                  }
                  else {
                    atomics = "atomic_add_global_xchg(A,B)";
                  }
                }
                else {
                  atomics = "*(A)+=(B)";
                }
                assert(1 <= bs && 0 < bm && 0 < bn && NULL != atomics);
                nchar = ACC_OPENCL_SNPRINTF(build_options, sizeof(build_options),
                  "%s -cl-fast-relaxed-math -cl-no-signed-zeros -cl-denorms-are-zero"
                  " -DGLOBAL=%s -DFN=%s -DSM=%i -DSN=%i -DSK=%i -DBM=%i -DBN=%i -DBS=%i"
                  " -DT=%s -DTA=\"%s\" -DFMA=fma -DCMPXCHG=%s -DXCHG=%s"
                  " -D\"ATOMIC_ADD_GLOBAL(A,B)=%s\"",
                  (NULL == env_options || '\0' == *env_options) ? "" : env_options,
                  EXIT_SUCCESS != opencl_libsmm_use_cmem(active_device) ? "global" : "constant",
                  fname, m_max, n_max, k_max, bm, bn, bs, typename,
                  atomic_type, atomic_cmpxchg, atomic_xchg, atomics);
                if (0 >= nchar || (int)sizeof(build_options) <= nchar) result = EXIT_FAILURE;
              }
              else {
                result = EXIT_FAILURE;
                ACC_OPENCL_ERROR("matrix-size causes too large WG-size", result);
              }
            }
            if (EXIT_SUCCESS == result) {
              config_t new_config;
#if defined(OPENCL_SOURCE_MULTIPLY)
              result = acc_opencl_kernel(OPENCL_SOURCE_MULTIPLY, build_options, fname, &new_config.kernel);
#else
              result = EXIT_FAILURE;
#endif
              if (EXIT_SUCCESS == result) {
                result = acc_opencl_wgsize(active_device, new_config.kernel,
                  &max_wgsize, NULL/*preferred_multiple*/);
                if (EXIT_SUCCESS == result) {
                  assert(0 < wgsize && 0 < max_wgsize);
                  /* check planned WG-size against kernel-specific WG-size */
                  if (wgsize <= max_wgsize) {
                    new_config.wgsize = (size_t)wgsize;
                    new_config.batchsize = bs;
                    config = (config_t*)OPENCL_LIBSMM_REGISTER(&key, sizeof(key),
                      sizeof(new_config), &new_config);
                  }
                  else {
                    result = EXIT_FAILURE;
                    ACC_OPENCL_ERROR("tile-size causes too large WG-size", result);
                  }
                }
              }
            }
          }
          else {
            result = EXIT_FAILURE;
            ACC_OPENCL_ERROR("insufficient device capabilities", result);
          }
        }
      }
      else {
        result = EXIT_FAILURE;
      }
    }
    assert(EXIT_SUCCESS != result || /* otherwise config must be valid */
      (NULL != config && NULL != config->kernel
        && 1 <= config->batchsize
        && 0 < config->wgsize));
    if (EXIT_SUCCESS == result) {
      /* adjust overall stacksize according to intra-kernel batchsize */
      const size_t work_size = ((stack_size + config->batchsize - 1) / config->batchsize) * config->wgsize;
#if defined(OPENCL_LIBSMM_DEBUG_SMM)
      char *ainp = NULL, *binp = NULL, *cinp = NULL, *test = NULL, *gold = NULL, *btrn = NULL;
      const libxsmm_gemm_precision precision = (dbcsr_type_real_8 == datatype
        ? LIBXSMM_GEMM_PRECISION_F64 : (dbcsr_type_real_4 == datatype ? LIBXSMM_GEMM_PRECISION_F32
        : (libxsmm_gemm_precision)LIBXSMM_DATATYPE_UNSUPPORTED));
      const int typesize = (dbcsr_type_real_8 == datatype ? 8
        : (dbcsr_type_real_4 == datatype ? 4 : 0/*unknown*/));
      size_t asize, bsize, csize;
      libxsmm_xmmfunction kernel = { NULL };
      if (  CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_a_data),
              CL_MEM_SIZE, sizeof(size_t), &asize, NULL)
        &&  CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_b_data),
              CL_MEM_SIZE, sizeof(size_t), &bsize, NULL)
        &&  CL_SUCCESS == clGetMemObjectInfo(*ACC_OPENCL_MEM(dev_c_data),
              CL_MEM_SIZE, sizeof(size_t), &csize, NULL))
      {
        const double alpha = 1, beta = 1;
        libxsmm_descriptor_blob blob;
        libxsmm_gemm_descriptor *const desc = libxsmm_gemm_descriptor_dinit(&blob,
          precision, m_max, n_max, k_max, m_max, k_max, m_max, alpha, beta,
          LIBXSMM_GEMM_FLAG_NONE, LIBXSMM_PREFETCH_NONE);
        ainp = (char*)libxsmm_aligned_scratch(asize, 0/*auto-align*/);
        binp = (char*)libxsmm_aligned_scratch(bsize, 0/*auto-align*/);
        test = (char*)libxsmm_aligned_scratch(csize, 0/*auto-align*/);
        gold = (char*)libxsmm_aligned_scratch(csize, 0/*auto-align*/);
        btrn = (char*)libxsmm_aligned_scratch(k_max * n_max * typesize, 0/*auto-align*/);
        if (NULL != desc && NULL != ainp && NULL != binp && NULL != test && NULL != gold && NULL != btrn) {
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_a_data, ainp, asize, stream),
            "transfer debug a-data", result);
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_b_data, binp, bsize, stream),
            "transfer debug b-data", result);
          ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_c_data, gold, csize, stream),
            "transfer debug c-data", result);
          kernel = libxsmm_xmmdispatch(desc);
          assert(NULL != kernel.xmm);
        }
        else result = EXIT_FAILURE;
      }
      else result = EXIT_FAILURE;
#endif
      assert(!(OPENCL_LIBSMM_NLOCKS_SMM & (OPENCL_LIBSMM_NLOCKS_SMM - 1))); /* POT */
      { /* OpenCL is thread-safe except for clSetKernelArg and launching such shared kernel */
        const unsigned int hash = libxsmm_hash(&config->kernel, sizeof(cl_kernel), 25071975/*seed*/);
        volatile int *const lock = opencl_libsmm_lock_smm + LIBXSMM_MOD2(hash, OPENCL_LIBSMM_NLOCKS_SMM);
        LIBXSMM_ATOMIC_ACQUIRE(lock, LIBXSMM_SYNC_NPAUSE, LIBXSMM_ATOMIC_RELAXED);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 0, sizeof(cl_mem), ACC_OPENCL_MEM(dev_c_data)),
          "set C-matrix argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 1, sizeof(cl_mem), ACC_OPENCL_MEM(dev_a_data)),
          "set A-matrix argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 2, sizeof(cl_mem), ACC_OPENCL_MEM(dev_b_data)),
          "set B-matrix argument of SMM-kernel", result);
        ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 3, sizeof(cl_mem), ACC_OPENCL_MEM(dev_param_stack)),
          "set batch-list argument of SMM-kernel", result);
        if (1 < config->batchsize) {
          ACC_OPENCL_CHECK(clSetKernelArg(config->kernel, 4, sizeof(int), &stack_size),
            "set stacksize argument of SMM-kernel", result);
        }
        ACC_OPENCL_CHECK(clEnqueueNDRangeKernel(*ACC_OPENCL_STREAM(stream),
          config->kernel, 1/*work_dim*/, NULL, &work_size, &config->wgsize, 0, NULL, NULL),
          "launch SMM-kernel", result);
        LIBXSMM_ATOMIC_RELEASE(lock, LIBXSMM_ATOMIC_RELAXED);
      }
#if defined(OPENCL_LIBSMM_DEBUG_SMM)
      ACC_OPENCL_CHECK(acc_memcpy_d2h(dev_c_data, test, csize, stream),
        "transfer debug test", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_SMM) || defined(OPENCL_LIBSMM_SYNC)
      ACC_OPENCL_CHECK(acc_stream_sync(stream), "sync stream", result);
#endif
#if defined(OPENCL_LIBSMM_DEBUG_SMM)
      if (EXIT_SUCCESS == result) {
        const char *const env_tol = getenv("OPENCL_LIBSMM_SMM_TOLERANCE");
        const double tolerance = ((NULL == env_tol || '\0' == *env_tol) ? 1E-3 : atof(env_tol));
        const int *const params = host_param_stack + (4 <= nparams ? (nparams - 4) : 0);
        size_t i;
        fprintf(stderr, "libsmm_acc_process(size=%i, type=%s, m=%i, n=%i, k=%i, max=%i, stream=%p)", stack_size,
          dbcsr_type_real_8 == datatype ? "f64" : (dbcsr_type_real_4 == datatype ? "f32" : "unknown"),
          m_max, n_max, k_max, max_kernel_dim, stream);
        for (i = 0; i < ((size_t)stack_size * nparams); i += nparams) {
          const size_t ia = (size_t)(params[i+0] - 1) * typesize;
          const size_t ib = (size_t)(params[i+1] - 1) * typesize;
          const size_t ic = (size_t)(params[i+2] - 1) * typesize;
          assert(ia < asize && ib < bsize && ic < csize);
          libxsmm_otrans(btrn, binp + ib, typesize, n_max, k_max, n_max, k_max);
          kernel.xmm(ainp + ia, btrn, gold + ic);
        }
        /* some result may be validated multiple times in case of duplicated c-indexes */
        for (i = 0; i < ((size_t)stack_size * nparams); i += nparams) {
          const size_t ic = (size_t)(params[i+2] - 1) * typesize;
          libxsmm_matdiff_info diff;
          libxsmm_matdiff(&diff, (libxsmm_datatype)precision, m_max, n_max,
            gold + ic, test + ic, &m_max/*ldref*/, &m_max/*ldtst*/);
          if (tolerance < diff.normf_rel) {
            fprintf(stderr, " => ERROR\n");
# if defined(_DEBUG)
            opencl_libsmm_print_matrix(stderr, "gold = ", datatype, gold + ic, m_max, n_max);
            opencl_libsmm_print_matrix(stderr, "test = ", datatype, test + ic, m_max, n_max);
            fprintf(stderr, "\n");
# endif
            result = EXIT_FAILURE; break;
          }
        }
        if (EXIT_SUCCESS == result) fprintf(stderr, " => OK\n");
      }
      libxsmm_free(ainp);
      libxsmm_free(binp);
      libxsmm_free(cinp);
      libxsmm_free(test);
      libxsmm_free(gold);
      libxsmm_free(btrn);
#elif defined(NDEBUG)
      ACC_OPENCL_UNUSED(host_param_stack);
      ACC_OPENCL_UNUSED(nparams);
#endif
    }
  }
  else if (0 < stack_size) { /* inhomogeneous, large kernel, or unsupported datatype */
    return -1; /* TODO: document result code to trigger host-fallback */
  }
  ACC_OPENCL_RETURN(result);
}

#if defined(__cplusplus)
}
#endif

#endif /*__OPENCL*/
